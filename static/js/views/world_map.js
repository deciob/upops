// Generated by CoffeeScript 1.4.0

define(['backbone', 'libs/utils', 'text!templates/world_map.html'], function(Backbone, utils, template) {
  'use strict';

  var WorldMap;
  return WorldMap = Backbone.View.extend({
    el: "#world_map",
    initialize: function(options) {
      this.options = options || {};
      this.dispatcher = options.dispatcher;
      this.defaultMessage = "World Map (main visualisation)";
      this.message = this.options.message || this.defaultMessage;
      return this.dispatcher.on('onSlide', this.updateChart, this);
    },
    circleDimension: d3.scale.linear().domain([1000, 38661000]).range([2, 30]),
    render: function(args) {
      var dimensions, height, path, scale, svg, trans, width;
      dimensions = this._getViewDimensions();
      width = dimensions.width;
      height = dimensions.height;
      scale = utils.getScale(width, height);
      trans = utils.getTranslation(scale);
      this.projection = d3.geo.robinson();
      this.projection.scale(scale);
      this.projection.translate([trans.x, trans.y]);
      path = d3.geo.path().projection(this.projection);
      svg = d3.select(this.el).append("svg").attr("width", width).attr("height", height);
      this.renderBaseMap(svg, path, args[1][0]);
      this.renderOverlay(svg, path, args[0]);
      return this.dataset = args[0];
    },
    renderBaseMap: function(svg, path, world) {
      var graticule;
      graticule = d3.geo.graticule();
      svg.append("path").datum(graticule.outline).attr("class", "background").attr("d", path);
      svg.append("g").attr("class", "graticule").selectAll("path").data(graticule.lines).enter().append("path").attr("d", path);
      svg.append("path").datum(graticule.outline).attr("class", "foreground").attr("d", path);
      svg.insert("path", ".graticule").datum(topojson.object(world, world.objects.land)).attr("class", "land").attr("d", path);
      return svg.insert("path", ".graticule").datum(topojson.mesh(world, world.objects.countries, function(a, b) {
        return a.id !== b.id;
      })).attr("class", "boundary").attr("d", path);
    },
    renderOverlay: function(svg, path, dataset) {
      var chart, g, self;
      self = this;
      g = svg.append("g");
      chart = function(row) {
        var xy;
        xy = this.projection([row.geometry.coordinates[0], row.geometry.coordinates[1]]);
        return g.append("circle").attr("r", 0).attr("cx", xy[0]).attr("cy", xy[1]).attr("id", "c_" + row._id).transition().duration(2000).attr("r", function(d) {
          return self.circleDimension(row.POP1950);
        });
      };
      return dataset.each(chart, this);
    },
    updateChart: function(year) {
      var self;
      self = this;
      return d3.select(this.el).selectAll("circle").datum(function() {
        var id, pop, selection;
        selection = d3.select(this);
        id = selection.attr('id').substring(2);
        pop = self.dataset.rowById(id)["POP" + year];
        return d3.select(this).transition().duration(500).attr("r", function() {
          return self.circleDimension(pop);
        });
      });
    },
    _getViewDimensions: function() {
      return {
        height: utils.getMiddleHeight(),
        width: $(this.el).innerWidth()
      };
    }
  });
});
